//available convention: 1, 2, 3, 4, 5, 6, 8, 10, 12, 15, 20, 24, 30, 40, 60, 120

let unitLength = 1.4;
//FN: inGame color change
//RGB Color Array [lifeDead,lifeBorn,lifeStageII,lifeStageIII,lifeStableI,lifeStableII]
let currentPtn = JSON.parse(JSON.stringify(ptnBeetles));
let ptnIdx = 0;
let colorSetDefault = [[162, 163, 157], [86, 86, 86], [76, 76, 76], [56, 56, 56], [46, 46, 46], [36, 36, 36]];
let colorSetYellow = [[96, 96, 96], [255, 187, 0], [204, 192, 20], [153, 147, 61], [64, 157, 255], [20, 158, 204]];
let colorSetLiGreen = [[96, 96, 96], [1, 255, 111], [20, 204, 204], [61, 153, 153], [255, 64, 109], [204, 20, 155]];
let colorSetPkm = [[46, 46, 46], [162, 163, 157], [255, 185, 0], [9, 1, 92], [23, 23, 23], [233, 233, 233]];
let drawColorSet = colorSetDefault;
let clrScaleIdx = 10;
let brushSize = 4;
const strokeColor = 'rgba(64,64,64,0.05)';
let columns; /* To be determined by window width */
let rows; /* To be determined by window height */
let currentBoard;
let nextBoard;
let canvasWidth = 252;
let canvasHeight = 168;
let imgBox = document.querySelector(".previewImg")
//Game Rules Var
let ruleLoneliness = 2;
let ruleOverpop = 3;
let ruleReproduction = 3;
let drawModeBool = true;
//Dark Mode
let darkMode = false;
//Game Setting Btn Var
let loadBtn = document.querySelector(`#loadImg`)
let clearBtn = document.querySelector(`#btnClear`);
let startBtn = document.querySelector(`#btnStart`)
let rangeObj = document.querySelector('#rangeObj');
let drawBtn = document.querySelector("#drawBtn")
let resOptA = document.querySelector('#monA');
let resOptB = document.querySelector('#monB');
let resOptC = document.querySelector('#monC');
let themeOptA = document.querySelector('#themeA');
let themeOptB = document.querySelector('#themeB');
let themeOptC = document.querySelector('#themeC');
let frameRange = document.querySelector('#frameRange');
let btnA = document.querySelector('#btnA')
let setFrameRate = frameRange.value;
let patternLoaded = false;

function setup() {
  /* Set the canvas to be under the element #canvas*/
  const canvas = createCanvas(canvasWidth, canvasHeight);
  canvas.parent(document.querySelector("#canvas"));
  /*Calculate the number of columns and rows */
  columns = floor(canvasWidth / unitLength);
  rows = floor(canvasHeight / unitLength);
  /*Making both currentBoard and nextBoard 2-dimensional matrix that has (columns * rows) boxes. */
  currentBoard = [];
  nextBoard = [];
  for (let i = 0; i < columns; i++) {
    currentBoard[i] = [];
    nextBoard[i] = [];
  }

  // Now both currentBoard and nextBoard are array of array of undefined values.
  randomGen();
}

function draw() {
  console.log("draw")
  frameRate(setFrameRate);
  background(255);
  generate();
  for (let i = 0; i < columns; i++) {
    for (let j = 0; j < rows; j++) {
      let lifeColor = Math.ceil(Math.min(currentBoard[i][j], 10) / 2);
      if (currentBoard[i][j] == 0) {
        fill(drawColorSet[0]);
      } else {
        let randomRange = 1 + ((Math.random() - Math.random()) * 0.5);
        fill(drawColorSet[lifeColor][0] * randomRange, drawColorSet[lifeColor][1] * randomRange, drawColorSet[lifeColor][2] * randomRange)
      }

      stroke(strokeColor);
      rect(i * unitLength, j * unitLength, unitLength, unitLength);
    }
  }
  if (!patternLoaded) {
    loadPattern();
    noLoop();
    patternLoaded = true;
  }
}

/**
* Initialize/reset the board state
*/
function init() {
  for (let i = 0; i < columns; i++) {
    for (let j = 0; j < rows; j++) {
      currentBoard[i][j] = 0;
      nextBoard[i][j] = 0;
    }
  }
}

function randomGen() {
  for (let i = 0; i < columns; i++) {
    for (let j = 0; j < rows; j++) {
      // Lining the edges with 0s
      if (i == 0 || j == 0 || i == columns - 1 || j == rows - 1) currentBoard[i][j] = 0;
      // Filling the rest randomly
      else currentBoard[i][j] = floor(random(2));
      nextBoard[i][j] = 0;
    }
  }
}

function generate() {
  //Loop over every single box on the board
  for (let x = 0; x < columns; x++) {
    for (let y = 0; y < rows; y++) {
      // Count all living members in the Moore neighborhood(8 boxes surrounding)
      let neighbors = 0;
      for (let i of [-1, 0, 1]) {
        for (let j of [-1, 0, 1]) {
          if (i == 0 && j == 0) {
            // the cell itself is not its own neighbor
            continue;
          }
          // The modulo operator is crucial for wrapping on the edge
          let neighborsVar;
          if (currentBoard[(x + i + columns) % columns][(y + j + rows) % rows] > 0) {
            neighborsVar = 1;
          } else {
            neighborsVar = 0
          }
          neighbors += neighborsVar;
        }
      }

      // Rules of Life
      if (currentBoard[x][y] >= 1 && neighbors < ruleLoneliness) {
        // Die of Loneliness
        nextBoard[x][y] = 0;
      } else if (currentBoard[x][y] >= 1 && neighbors > ruleOverpop) {
        // Die of Overpopulation
        nextBoard[x][y] = 0;
      } else if (currentBoard[x][y] == 0 && neighbors == ruleReproduction) {
        // New life due to Reproduction
        nextBoard[x][y] = 1;
      } else if (currentBoard[x][y] >= 1 && nextBoard[x][y] >= 1) {
        nextBoard[x][y] += 1;
      } else {
        // Stasis
        nextBoard[x][y] = currentBoard[x][y];
      }
    }
  }

  // Swap the nextBoard to be the current Board
  [currentBoard, nextBoard] = [nextBoard, currentBoard];
}

/*Mouse dragged*/
function mouseDragged() {
  /* If the mouse coordinate is outside the board*/
  if (mouseX > unitLength * columns || mouseY > unitLength * rows) {
    return;
  }
  const x = Math.floor(mouseX / unitLength);
  const y = Math.floor(mouseY / unitLength);

  let brhScale = Math.floor(brushSize / 2);
  for (let idx = x - brhScale; idx < x + brhScale; idx++) {
    for (let idxY = y - brhScale; idxY < y + brhScale; idxY++) {
      currentBoard[idx][idxY] = Number(drawModeBool);
      if (currentBoard[idx][idxY] == 0) {
        fill(drawColorSet[0]);
      } else {
        let randomRange = 1 + ((Math.random() - Math.random()) * 0.5);
        fill(drawColorSet[1][0] * randomRange, drawColorSet[1][1] * randomRange, drawColorSet[1][2] * randomRange)
      }
      stroke(strokeColor);
      rect(idx * unitLength, idxY * unitLength, unitLength, unitLength);
    }
  }
}

/**
 * When mouse is pressed
 */
function mousePressed() {
  if (mouseX > unitLength * columns || mouseY > unitLength * rows) {
    return;
  }
  noLoop();
  mouseDragged();
}

/**
 * When mouse is released
 */
function mouseReleased() {
}

/*Buttons Setup*/
window.onload = function () {

  window.addEventListener("resize", (e) => { init() });
  startBtn.addEventListener("click", (e) => (loop()));
  btnClear.addEventListener("click", (e) => (init(), loop()));
  document.querySelector("#drawBtn").addEventListener("click", (e) => {
    if (drawModeBool) {
      drawBtn.innerHTML = "Draw";
      drawModeBool = !drawModeBool;
    } else {
      drawBtn.innerHTML = "Erase";
      drawModeBool = !drawModeBool;
    }
  })
  resOptA.addEventListener("click", (e) => {
    resOptA.classList.add("active");
    resOptB.classList.remove("active");
    resOptC.classList.remove("active");
    unitLength = 2;
    setup();
    draw();
    loop();
  })

  resOptB.addEventListener("click", (e) => {
    resOptB.classList.add("active");
    resOptA.classList.remove("active");
    resOptC.classList.remove("active");
    unitLength = 4;
    setup();
    draw();
    loop();
  })

  resOptC.addEventListener("click", (e) => {
    resOptC.classList.add("active");
    resOptB.classList.remove("active");
    resOptA.classList.remove("active");
    unitLength = 6;
    setup();
    draw();
    loop();
  })

  frameRange.addEventListener("input", (e) => {
    setFrameRate = frameRange.value;
    document.querySelector('#rangeLabel').innerHTML = `已選擇 ${setFrameRate}Hz`
    frameRate(Number(setFrameRate));
  })

  loadBtn.addEventListener("click", (e) => {
    loadPattern();
  });

  themeOptA.addEventListener("click", (e) => {
    themeOptA.classList.add("active");
    themeOptB.classList.remove("active");
    themeOptC.classList.remove("active");
    changeTheme(themeYellow);
    drawColorSet = colorSetDefault;
  })

  themeOptB.addEventListener("click", (e) => {
    themeOptB.classList.add("active");
    themeOptA.classList.remove("active");
    themeOptC.classList.remove("active");
    changeTheme(themeGreen);
    drawColorSet = colorSetYellow;
  })

  themeOptC.addEventListener("click", (e) => {
    themeOptC.classList.add("active");
    themeOptB.classList.remove("active");
    themeOptA.classList.remove("active");
    changeTheme(themeBlue);
    drawColorSet = colorSetLiGreen;
  })

  btnA.addEventListener("click", (e) => {
    printPtn(currentPtn);
  })
  //Keyboard event listener
  document.addEventListener("keydown", (e) => {
    console.log(`Code:${e.code},Key:${e.key}`)
    if (e.code == 'KeyA') {
      printPtn(currentPtn);
    } else if (e.code == 'KeyS') {
      startBtn.click();
    } else if (e.code == 'KeyC') {
      clearBtn.click();
    } else if (e.code == 'KeyD') {
      darkModeSwitch();
    } else if (e.code == 'ArrowLeft'){
      switchPatern(-1);

    } else if (e.code == 'ArrowRight'){
      switchPatern(1);
    }
  })
}

function switchPatern(x){
  ptnIdx += x;
  if(ptnIdx>=ptnList.length){
    ptnIdx = 0;
  }
  currentPtn = ptnList[ptnIdx];
  imgBox.setAttribute("src",currentPtn["preview"])
}

/*Load Screen-size-pattern */
function loadPattern() {
  currentBoard = JSON.parse(JSON.stringify(ptnPkm));
  nextBoard = [...currentBoard];
  for (let i = 0; i < columns; i++) {
    for (let j = 0; j < rows; j++) {
      let lifeColor = currentBoard[i][j];
      if (currentBoard[i][j] == 0) {
        fill(colorSetPkm[0]);
      } else {
        fill(colorSetPkm[lifeColor])
      }
      stroke(strokeColor);
      rect(i * unitLength, j * unitLength, unitLength, unitLength);
    }
  }
}


//get css root var
let cssRoot = document.querySelector(':root');
//FN: Gameboy Theme Change 
let themeYellow = {
  "--gb-theme-body": "#FFD428",
  "--gb-theme-side-1": "#FFD91D",
  "--gb-theme-side-2": "#FFBF1D",
  "--gb-theme-side-3": "#FFCF28",
  "--gb-theme-side-4": "#FFE57D",
  "--gb-theme-light": "#FFEEA3",
  "--gb-theme-shadow": "#FFAB61",
  "--gb-spkr-dark": "#FF8D29",
  "--gb-txt-shahow": "rgba(0, 0, 0, 0.3)",
  "--gb-grey-0": "#AAA",
  "--gb-grey-1": "#888",
  "--gb-grey-2": "#444",
  "--gb-grey-3": "#383838",
  "--gb-grey-4": "#353535",
  "--spkr-shadow": "rgba(255, 255, 255, 0.5)"
}

let themeGreen = {
  "--gb-theme-body": "#00d289",
  "--gb-theme-side-1": "#40de9d",
  "--gb-theme-side-2": "#19964f",
  "--gb-theme-side-3": "#23703c",
  "--gb-theme-side-4": "#6af2aa",
  "--gb-theme-light": "hsl(145, 83%, 62%)",
  "--gb-theme-shadow": "#4ac79357",
  "--gb-spkr-dark": "#47ca8d",
  "--gb-txt-shahow": "rgba(0, 0, 0, 0.3)",
  "--gb-grey-0": "#AAA",
  "--gb-grey-1": "#888",
  "--gb-grey-2": "#444",
  "--gb-grey-3": "#383838",
  "--gb-grey-4": "#353535",
  "--spkr-shadow": "rgba(16, 16, 16, 0.5)"
}


let themeBlue = {
  "--gb-theme-body": "#04bbc8",
  "--gb-theme-side-1": "#40ccde",
  "--gb-theme-side-2": "#248c9a",
  "--gb-theme-side-3": "#49b9b9",
  "--gb-theme-side-4": "#75dff5",
  "--gb-theme-light": "#8ce5f3",
  "--gb-theme-shadow": "#297276",
  "--gb-spkr-dark": "#1c8597",
  "--gb-txt-shahow": "rgba(0, 0, 0, 0.3)",
  "--gb-grey-0": "#AAA",
  "--gb-grey-1": "#888",
  "--gb-grey-2": "#444",
  "--gb-grey-3": "#383838",
  "--gb-grey-4": "#353535",
  "--spkr-shadow": "rgba(16, 16, 16, 0.5)"
}

function changeTheme(myTheme) {
  for (let itm of Object.keys(myTheme)) {
    cssRoot.style.setProperty(itm, myTheme[itm]);
  }
}


function printPtn(patternObj) {
  if (mouseX > unitLength * columns || mouseY > unitLength * rows) {
    return;
  }
  //assign print position 
  let loadPattern = JSON.parse(JSON.stringify(patternObj))
  let ptnWidth = loadPattern["width"];
  let ptnHeight = loadPattern["height"];
  let posiX = Math.floor(mouseX / unitLength);
  let posiY = Math.floor(mouseY / unitLength);
  let printCounter = 0;
  for (let i = posiX; i < posiX + ptnWidth; i++) {
    let printCounter = i - posiX;
    for (let j = posiY; j < posiY + ptnHeight; j++) {
      currentBoard[i][j] = loadPattern["data"][printCounter];
      printCounter += ptnWidth;
      if (currentBoard[i][j] == 0) {
        fill(drawColorSet[0]);
      } else {
        let randomRange = 1 + ((Math.random() - Math.random()) * 0.5);
        fill(drawColorSet[1][0] * randomRange, drawColorSet[1][1] * randomRange, drawColorSet[1][2] * randomRange)
      }
      stroke(strokeColor);
      rect(i * unitLength, j * unitLength, unitLength, unitLength);
    }
  }
}

/*function printPtn(patternObj) {
  //assign print position 
  let loadPattern = JSON.parse(JSON.stringify(patternObj))
  let ptnWidth = loadPattern["width"];
  let ptnHeight = loadPattern["height"];
  let posiX = Math.ceil((columns - ptnWidth) / 2);
  let posiY = rows - ptnHeight - 12;
  let printCounter = 0;
  for (let i = posiX; i < posiX + ptnWidth; i++) {
    let printCounter = i - posiX;
    for (let j = posiY; j < posiY + ptnHeight; j++) {
      currentBoard[i][j] = loadPattern["data"][printCounter];
      printCounter += ptnWidth;
      if (currentBoard[i][j] == 0) {
        fill(drawColorSet[0]);
      } else {
        let randomRange = 1 + ((Math.random() - Math.random()) * 0.5);
        fill(drawColorSet[1][0] * randomRange, drawColorSet[1][1] * randomRange, drawColorSet[1][2] * randomRange)
      }
      stroke(strokeColor);
      rect(i * unitLength, j * unitLength, unitLength, unitLength);
    }
  }
}*/

function darkModeSwitch() {
  if (!darkMode) {
    document.querySelector("body").classList.add("active");
  } else {
    document.querySelector("body").classList.remove("active");
  }
  darkMode = !darkMode;
}